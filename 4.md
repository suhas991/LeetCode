# React `useContext` Hook – Detailed Notes

## 1. What is `useContext`?

* The `useContext` hook in React allows you to access values from a **Context** directly without manually passing props (avoids **prop drilling**).
* Context provides a way to share values like theme, authentication, or user settings across the component tree.

---

## 2. Why `useContext`?

* In large applications, passing props through multiple layers becomes messy (**prop drilling problem**).
* `useContext` solves this by providing a **global state** that can be accessed by any component inside the `Context.Provider`.

**Example of prop drilling (problem):**

```jsx
function App() {
  return <Parent theme="dark" />;
}

function Parent({ theme }) {
  return <Child theme={theme} />;
}

function Child({ theme }) {
  return <div>Theme is {theme}</div>;
}
```

With **useContext**, we avoid passing `theme` manually.

---

## 3. Creating and Using Context with `useContext`

### Step 1: Create Context

```jsx
import React, { createContext, useContext } from "react";

// Create a Context
const ThemeContext = createContext();
```

### Step 2: Provide Context Value

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}
```

### Step 3: Consume Context Value using `useContext`

```jsx
function Child() {
  const theme = useContext(ThemeContext); // Access context
  return <div>Theme is {theme}</div>;
}
```

---

## 4. Updating Context Value

```jsx
import React, { createContext, useContext, useState } from "react";

const UserContext = createContext();

function App() {
  const [user, setUser] = useState("Suhas");

  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Profile />
    </UserContext.Provider>
  );
}

function Profile() {
  const { user, setUser } = useContext(UserContext);

  return (
    <div>
      <h2>User: {user}</h2>
      <button onClick={() => setUser("NH")}>Change User</button>
    </div>
  );
}
```

* Here, both `user` and `setUser` are shared globally.

---

## 5. `useContext` with Multiple Contexts

```jsx
const ThemeContext = createContext();
const AuthContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="light">
      <AuthContext.Provider value={{ loggedIn: true }}>
        <Dashboard />
      </AuthContext.Provider>
    </ThemeContext.Provider>
  );
}

function Dashboard() {
  const theme = useContext(ThemeContext);
  const auth = useContext(AuthContext);

  return <p>Theme: {theme}, Logged in: {auth.loggedIn.toString()}</p>;
}
```

---

## 6. Best Practices

✅ Keep context values small and specific (don’t put entire app state in one context).
✅ Use multiple contexts for separation of concerns (Auth, Theme, Language).
✅ Don’t overuse context – it’s not a replacement for state management libraries.
✅ Use custom hooks to simplify context usage.

**Example – Custom Hook for UserContext:**

```jsx
const UserContext = createContext();

export function useUser() {
  return useContext(UserContext);
}
```

Now, instead of calling `useContext(UserContext)` everywhere, just call `useUser()`.

---

## 7. `useContext` vs Redux

| Feature        | useContext                              | Redux                                               |
| -------------- | --------------------------------------- | --------------------------------------------------- |
| Use case       | Small/medium apps, simple state sharing | Large apps, complex state management                |
| Boilerplate    | Minimal                                 | Requires setup (reducers, actions, store)           |
| Performance    | May cause re-renders if not optimized   | Optimized with middlewares & selective subscription |
| Async Handling | Manual (with useReducer/useEffect)      | Built-in middleware (Redux Thunk, Saga)             |

**When to use `useContext`:**

* Small apps.
* Sharing theme, user info, auth state.

**When to use Redux:**

* Large-scale applications.
* Complex async state management.
* Multiple developers working on shared state.

---

## 8. Summary

* `useContext` helps avoid prop drilling.
* Use with `createContext` + `Provider`.
* Ideal for global values (theme, auth, user).
* For large apps with complex logic, prefer Redux or other state managers.
