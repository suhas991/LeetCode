# React `useContext` Hook â€“ Detailed Notes

# ðŸ“Œ Prop Drilling in React

---

## ðŸ”¹ What is Prop Drilling?

* **Prop drilling** is the process of passing data from a **parent component** down to deeply nested **child components** through **props**, even if the intermediate components donâ€™t need the data.
* The intermediate components act only as "pass-through" layers.

---

## ðŸ”¹ Why does it happen?

* React follows a **unidirectional data flow** (top â†’ down).
* Data can only flow **from parent to child** via props.
* If a deeply nested component needs some data, but it originates from a parent (or higher-level ancestor), every intermediate component must forward that prop, leading to *prop drilling*.

---

## ðŸ”¹ Example of Prop Drilling

```jsx
import React from "react";

function App() {
  const user = { name: "Suhas", role: "Developer" };

  return <Parent user={user} />;
}

function Parent({ user }) {
  return <Child user={user} />;
}

function Child({ user }) {
  return <GrandChild user={user} />;
}

function GrandChild({ user }) {
  return (
    <div>
      <h2>Name: {user.name}</h2>
      <h3>Role: {user.role}</h3>
    </div>
  );
}

export default App;
```

ðŸ‘‰ Here, `user` is passed from `App â†’ Parent â†’ Child â†’ GrandChild`.

* But **Parent** and **Child** donâ€™t actually need it â€” they just forward it.
* Thatâ€™s **prop drilling**.

---

## ðŸ”¹ Problems with Prop Drilling

1. **Unnecessary code clutter** â€“ Intermediate components pass props they donâ€™t use.
2. **Harder maintenance** â€“ If the prop structure changes, many components must be updated.
3. **Reduced readability** â€“ Too many props make the component tree messy.
4. **Tight coupling** â€“ Intermediate components depend on props unnecessarily.

---

## ðŸ”¹ Solutions to Avoid Prop Drilling

### 1. React Context API

* Provides a way to share values across the component tree **without manually passing props**.

```jsx
import React, { createContext, useContext } from "react";

const UserContext = createContext();

function App() {
  const user = { name: "Suhas", role: "Developer" };
  return (
    <UserContext.Provider value={user}>
      <Parent />
    </UserContext.Provider>
  );
}

function Parent() {
  return <Child />;
}

function Child() {
  return <GrandChild />;
}

function GrandChild() {
  const user = useContext(UserContext);
  return (
    <div>
      <h2>Name: {user.name}</h2>
      <h3>Role: {user.role}</h3>
    </div>
  );
}

export default App;
```

ðŸ‘‰ Now no intermediate component (`Parent`, `Child`) has to pass the `user` prop.

---

### 2. State Management Libraries

* Use tools like **Redux, Zustand, MobX, Recoil** for global state management when the app scales.
* Helps manage complex state shared across many components.

### 3. Component Composition

* Instead of passing props down multiple levels, you can **compose components** and directly pass props to where they are needed.

---

## ðŸ”¹ When is Prop Drilling Okay?

* In **small apps** or when data only needs to pass **1â€“2 levels deep**, prop drilling is fine.
* Problems appear in **large apps** with deeply nested components.

---

## âœ… Summary

* **Prop Drilling** = Passing props through many levels unnecessarily.
* Causes **code clutter, maintainability issues, and reduced readability**.
* **Solutions** = Context API, Redux/Zustand, or composition.


## 1. What is `useContext`?

* The `useContext` hook in React allows you to access values from a **Context** directly without manually passing props (avoids **prop drilling**).
* Context provides a way to share values like theme, authentication, or user settings across the component tree.

---

## 2. Why `useContext`?

* In large applications, passing props through multiple layers becomes messy (**prop drilling problem**).
* `useContext` solves this by providing a **global state** that can be accessed by any component inside the `Context.Provider`.

**Example of prop drilling (problem):**

```jsx
function App() {
  return <Parent theme="dark" />;
}

function Parent({ theme }) {
  return <Child theme={theme} />;
}

function Child({ theme }) {
  return <div>Theme is {theme}</div>;
}
```

With **useContext**, we avoid passing `theme` manually.

---

## 3. Creating and Using Context with `useContext`

### Step 1: Create Context

```jsx
import React, { createContext, useContext } from "react";

// Create a Context
const ThemeContext = createContext();
```

### Step 2: Provide Context Value

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}
```

### Step 3: Consume Context Value using `useContext`

```jsx
function Child() {
  const theme = useContext(ThemeContext); // Access context
  return <div>Theme is {theme}</div>;
}
```

---

## 4. Updating Context Value

```jsx
import React, { createContext, useContext, useState } from "react";

const UserContext = createContext();

function App() {
  const [user, setUser] = useState("Suhas");

  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Profile />
    </UserContext.Provider>
  );
}

function Profile() {
  const { user, setUser } = useContext(UserContext);

  return (
    <div>
      <h2>User: {user}</h2>
      <button onClick={() => setUser("NH")}>Change User</button>
    </div>
  );
}
```

* Here, both `user` and `setUser` are shared globally.

---

## 5. `useContext` with Multiple Contexts

```jsx
const ThemeContext = createContext();
const AuthContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="light">
      <AuthContext.Provider value={{ loggedIn: true }}>
        <Dashboard />
      </AuthContext.Provider>
    </ThemeContext.Provider>
  );
}

function Dashboard() {
  const theme = useContext(ThemeContext);
  const auth = useContext(AuthContext);

  return <p>Theme: {theme}, Logged in: {auth.loggedIn.toString()}</p>;
}
```

---

## 6. Best Practices

âœ… Keep context values small and specific (donâ€™t put entire app state in one context).
âœ… Use multiple contexts for separation of concerns (Auth, Theme, Language).
âœ… Donâ€™t overuse context â€“ itâ€™s not a replacement for state management libraries.
âœ… Use custom hooks to simplify context usage.

**Example â€“ Custom Hook for UserContext:**

```jsx
const UserContext = createContext();

export function useUser() {
  return useContext(UserContext);
}
```

Now, instead of calling `useContext(UserContext)` everywhere, just call `useUser()`.

---

## 7. `useContext` vs Redux

| Feature        | useContext                              | Redux                                               |
| -------------- | --------------------------------------- | --------------------------------------------------- |
| Use case       | Small/medium apps, simple state sharing | Large apps, complex state management                |
| Boilerplate    | Minimal                                 | Requires setup (reducers, actions, store)           |
| Performance    | May cause re-renders if not optimized   | Optimized with middlewares & selective subscription |
| Async Handling | Manual (with useReducer/useEffect)      | Built-in middleware (Redux Thunk, Saga)             |

**When to use `useContext`:**

* Small apps.
* Sharing theme, user info, auth state.

**When to use Redux:**

* Large-scale applications.
* Complex async state management.
* Multiple developers working on shared state.

---

## 8. Summary

* `useContext` helps avoid prop drilling.
* Use with `createContext` + `Provider`.
* Ideal for global values (theme, auth, user).
* For large apps with complex logic, prefer Redux or other state managers.
