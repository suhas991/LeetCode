# 🧵 Multi-Threading in Java

## 📌 Introduction

* **Multithreading** is a process of executing multiple threads simultaneously to maximize CPU utilization.
* Each **thread** is a lightweight unit of a process.
* Java provides built-in support for multithreaded programming.

---

## ✅ Benefits of Multithreading

* Efficient CPU utilization.
* Handles multiple tasks simultaneously.
* Useful for tasks like gaming, animations, real-time systems, and servers.
* Improves performance in I/O-bound operations.

---

## 🔄 Thread Lifecycle

A thread in Java goes through different states:

```plaintext
New ---> Runnable ---> Running ---> Waiting/Blocked ---> Terminated
```

### ASCII Diagram:

```plaintext
   [NEW]
     |
     v
 [RUNNABLE] --> [RUNNING] --> [WAITING/BLOCKED]
     |                               |
     +-------------------------------+
                     |
                     v
               [TERMINATED]
```

---

## 🏗️ Creating Threads

### 1. By extending `Thread` class

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // Start a new thread
    }
}
```

### 2. By implementing `Runnable` interface

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread is running...");
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
```

### 3. Using `ExecutorService` (preferred for large apps)

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.execute(() -> System.out.println("Task 1 running..."));
        executor.execute(() -> System.out.println("Task 2 running..."));

        executor.shutdown();
    }
}
```

---

## ⚙️ Common Thread Methods

| Method        | Description                                               |
| ------------- | --------------------------------------------------------- |
| `start()`     | Starts a new thread                                       |
| `run()`       | Defines the code executed by the thread                   |
| `sleep(ms)`   | Makes the thread sleep for given time                     |
| `join()`      | Waits for a thread to finish                              |
| `yield()`     | Suggests thread scheduler to give chance to other threads |
| `interrupt()` | Interrupts a sleeping or waiting thread                   |
| `isAlive()`   | Checks if thread is still running                         |

---

## 🔐 Synchronization

* Used to prevent **race conditions** when multiple threads access shared resources.

### Example:

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class SyncExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.increment();
        });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("Final Count: " + counter.getCount());
    }
}
```

---

## ⚠️ Deadlocks

* Occurs when two or more threads wait indefinitely for each other’s resources.
* Example:

  * Thread A locks `Resource1` and waits for `Resource2`.
  * Thread B locks `Resource2` and waits for `Resource1`.

### Prevention:

* Acquire locks in the same order.
* Use `tryLock()` with timeout.
* Avoid nested locks if possible.

---

## 🏊 Thread Pools

* Created using `ExecutorService`.
* Reuses threads instead of creating new ones.
* Improves performance in high-load applications like servers.

---

## 🌍 Real-world Examples

1. Web servers handling multiple client requests.
2. Banking systems processing multiple transactions.
3. Gaming engines for rendering, physics, and AI simultaneously.
4. File download managers.

---

## ✅ Best Practices

* Prefer `ExecutorService` over manually creating threads.
* Always handle exceptions inside threads.
* Use synchronization only when necessary (avoid bottlenecks).
* Avoid thread leaks by shutting down executors.
* Keep tasks small for better scheduling.

---

📌 **In short:**
Multithreading makes programs faster and more efficient but requires careful handling of synchronization and resource sharing to avoid deadlocks.
