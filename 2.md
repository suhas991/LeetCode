# Higher Order Components (HOCs) in ReactJS

---

## 📌 What is a Higher Order Component?

* A **Higher Order Component (HOC)** is an **advanced technique** in React for **reusing component logic**.
* **Definition**: A Higher Order Component is a **function that takes a component as an argument and returns a new component** with additional props or functionality.
* HOCs are **not part of React API**, but rather a **design pattern**.

---

## 📌 Why Use HOCs?

* **Code Reusability**: Share logic across multiple components.
* **Cross-Cutting Concerns**: Add common functionality like authentication, logging, theming, etc.
* **Separation of Concerns**: Keep components clean by moving reusable logic into HOCs.

---

## 📌 Syntax

```jsx
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

* **`WrappedComponent`** → Original component
* **`higherOrderComponent`** → Function that returns a new component
* **`EnhancedComponent`** → New component with extended functionality

---

## 📌 Example 1: Authentication HOC

```jsx
import React from "react";

function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const isLoggedIn = localStorage.getItem("auth") === "true";

    if (!isLoggedIn) {
      return <h2>Please login to access this page</h2>;
    }

    return <WrappedComponent {...props} />;
  };
}

// Usage
function Dashboard() {
  return <h1>Welcome to the Dashboard!</h1>;
}

export default withAuth(Dashboard);
```

✅ The HOC checks login state before rendering the component.

---

## 📌 Example 2: Logger HOC

```jsx
import React, { useEffect } from "react";

function withLogger(WrappedComponent) {
  return function LoggedComponent(props) {
    useEffect(() => {
      console.log(`Component ${WrappedComponent.name} mounted`);
      return () => console.log(`Component ${WrappedComponent.name} unmounted`);
    }, []);

    return <WrappedComponent {...props} />;
  };
}

// Usage
function Profile() {
  return <h1>User Profile</h1>;
}

export default withLogger(Profile);
```

✅ The HOC logs lifecycle events of the wrapped component.

---

## 📌 Flow Diagram of HOCs

```
          ┌─────────────────────────┐
          │  WrappedComponent (UI)  │
          └───────────▲─────────────┘
                      │
                      │  Passed into
                      │
          ┌─────────────────────────┐
          │  HigherOrderComponent   │
          │ (adds logic/props)      │
          └───────────▲─────────────┘
                      │
                      │  Returns new
                      │
          ┌─────────────────────────┐
          │ EnhancedComponent (HOC) │
          │  = Extra Features + UI  │
          └─────────────────────────┘
```

---

## 📌 Rules of HOCs

1. Do **not mutate** the original component — always return a new one.
2. HOCs should be **pure functions** (no side effects).
3. Pass down **props transparently** using `{...props}`.
4. Apply **naming conventions** → `withSomething(WrappedComponent)`.

---

## 📌 HOC vs Alternatives

| Pattern          | Use Case                                                                  |
| ---------------- | ------------------------------------------------------------------------- |
| **HOCs**         | Share logic across multiple components (authentication, logging, etc.)    |
| **Render Props** | Share logic using a render function instead of wrapping                   |
| **Custom Hooks** | Share logic using hooks (preferred in modern React with functional comps) |

---

## 📌 Best Practices

* Use **HOCs for cross-cutting concerns** (auth, logging, theming).
* Prefer **Custom Hooks** in modern React (simpler, less nesting).
* Name HOCs properly: `withAuth`, `withLogger`, `withTheme`, etc.
* Always **forward props** to avoid blocking component functionality.

---

## 📌 Common Use Cases

* Authentication (`withAuth`)
* Logging/Analytics (`withLogger`)
* Error Boundaries (`withErrorBoundary`)
* Theming (`withTheme`)
* Data Fetching (`withData`)

---
